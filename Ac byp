-- // Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- // Settings
local Settings = {
    Prediction = 0.13,
    FOVRadius = 60,
    FOVColor = Color3.fromRGB(255, 0, 0),
    ShowFOV = true,
    SilentAimEnabled = false,
}

-- // FOV Drawing
local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = Settings.FOVRadius
FOVCircle.Thickness = 2
FOVCircle.Transparency = 1
FOVCircle.Filled = false
FOVCircle.Color = Settings.FOVColor
FOVCircle.Visible = Settings.ShowFOV

-- // Update FOV Position (centered for all devices)
RunService.RenderStepped:Connect(function()
    local viewSize = Camera.ViewportSize
    FOVCircle.Position = Vector2.new(viewSize.X / 2, viewSize.Y / 2)
end)

-- // Target Finder
local function GetClosestTarget()
    local closest = nil
    local closestPart = nil
    local shortestDist = math.huge
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local pos, visible = Camera:WorldToViewportPoint(hrp.Position)

            if visible then
                local dist = (Vector2.new(pos.X, pos.Y) - screenCenter).Magnitude
                if dist < Settings.FOVRadius and dist < shortestDist then
                    closest = player
                    closestPart = hrp
                    shortestDist = dist
                end
            end
        end
    end

    return closest, closestPart
end

-- // Input Button (for mobile toggle)
local function CreateMobileToggleButton()
    if not UserInputService.TouchEnabled then return end

    local screenGui = Instance.new("ScreenGui", game.CoreGui)
    screenGui.Name = "SilentAimToggle"

    local button = Instance.new("TextButton", screenGui)
    button.Size = UDim2.new(0, 100, 0, 40)
    button.Position = UDim2.new(1, -110, 1, -60)
    button.Text = "Silent Aim: OFF"
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.TextColor3 = Color3.new(1, 1, 1)
    button.BorderSizePixel = 0

    button.MouseButton1Click:Connect(function()
        Settings.SilentAimEnabled = not Settings.SilentAimEnabled
        button.Text = Settings.SilentAimEnabled and "Silent Aim: ON" or "Silent Aim: OFF"
    end)
end
CreateMobileToggleButton()

-- // Silent Aim Logic
local SilentTarget = nil
local SilentPart = nil

RunService.RenderStepped:Connect(function()
    if Settings.SilentAimEnabled then
        local target, part = GetClosestTarget()
        SilentTarget = target
        SilentPart = part
    else
        SilentTarget = nil
        SilentPart = nil
    end
end)

-- // Hook __namecall for silent aim
local mt = getrawmetatable(game)
setreadonly(mt, false)
local old = mt.__namecall

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()

    if tostring(self) == "MainEvent" and method == "FireServer" then
        local action = args[1]
        if action == "UpdateMousePos" and SilentPart and Settings.SilentAimEnabled then
            -- Replace mouse position with target position
            args[2] = SilentPart.Position + SilentPart.Velocity * Settings.Prediction
            return old(self, unpack(args))
        end
    end

    return old(self, ...)
end)

setreadonly(mt, true)
